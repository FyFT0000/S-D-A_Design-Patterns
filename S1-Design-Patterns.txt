https://www.coursera.org/learn/design-patterns?specialization=software-design-architecture

Design Patterns
    Introduction to Design Patterns: Creational & Structural Patterns


2.1.1   What is a Design Pattern?
A design pattern is a practical proven solution to a recurring design problem. Instead of solving a particular software problem by basic objectory into programming principles every time, where you would have to decide what objects to use? How objects need to relate and so on? You can use previously outlined solutions that expert developers have often used.

Pattern Languages: is a collection of patterns that are related to a certain problem space. Based on context, you must decide which ones will suit your problem or design issue the best. However, sometimes you must consider trade-offs in design – some patterns may be more resource-intensive.

2.1.2   Categories of Patterns: The Gang of Four’s pattern catalog contains 23 patterns. These patterns can be sorted into three different categories: creational patterns, structural patterns, and behavioral patterns. Some patterns might have elements that allow them to span all of the categories – it is not always clear cut which categories a pattern falls under.
The different ways of creating objects will greatly influence how a problem is solved. Therefore, different languages therefore impact what patterns are possible to use.
_   Creational patterns: tackle how you handle creating or cloning new objects. Cloning an object occurs when you are creating an object that is similar to an existing one, and instead of instantiating a new object, you clone existing objects instead of instantiating them.
The different ways of creating objects will greatly influence how a problem is solved. Therefore, different languages therefore impact what patterns are possible to use.
_   Structural patterns: describe how objects are connected to each other. These patterns relate to the design principles of decomposition and generalization, as discussed in the first course in this specialization. Also describe how subclasses and classes interact through inheritance. Structural patterns use these relationships and describe how they should work to achieve a particular design goal. Each structural pattern determines the various suitable relationships among the objects.
_   Behavioral patterns: focus on how objects distribute work and describe how each object does a single cohesive function. Behavioral patterns also focus on how independent objects work towards a common goal.

2.1.3   Singleton Pattern (Creational)
Describes a way to create an object. It is a powerful technique, but it is also one of the simplest examples of a design pattern.
_   A singleton design pattern only has one object of a class. This might be desirable in order to circumvent conflicts or inconsistencies, by keeping clear which object the program should draw from. For example, the preferences of an app, the print queue of your printer, or the software driver for a device are all objects where it is preferable to only have one. If there are multiple instances, it can be confusing for the program output.
_   Another goal of the singleton design pattern is that the single object is globally accessible within the program.
_   In order to implement a singleton design pattern, the best practice is to build the “one and only one” goal into the class itself so that creating another instance of a Singleton class is not even possible. This “codifies” the design intent within the software. This is necessary if working on a large project or on projects with multiple developers, but it is helpful even on smaller or individual projects.
_   A Singleton class Lazy creation version means that the object is not created until it is truly needed. This is helpful, especially if the object is large. As the object is not created until the “getInstance” method is called, the program is more efficient.
_   There are trade-offs to the Singleton design principle. If there are multiple computing threads running, there could be issues caused by the threads trying to access the shared single object.
_   In real use, there may be variations of how Singleton is realized because design patterns are defined by purpose and not exact code. The intent of a Singleton pattern is to provide global access to a class that is restricted to one instance. In general, this is achieved by having a private constructor with a public method that instantiates the class “if” it is not already instantiated.

2.1.4   Factory Method Pattern (Creational)
In order to understand the Factory method pattern, we must first understand factory objects.
Factory object:
_   Operates like a factory in the real world, and creates objects. Factory objects make software easier to maintain, change, test, and reuse because it deals with the problem of creating objects without having to specify the class. The methods that use these factories can then focus on other behaviors.
_   A factory object is an object whose role is to create “product” objects of particular types.
_   The act of instantiating a class to create an object of a specific type is known as concrete instantiation. In Java, concrete instantiation is indicated with the operator “new”.
_   Benefits of Factory Objects:
    _It is much simpler to add new types of an object to the object factory without modifying the client code. Instead of hunting down multiple snippets of similar instantiation code, subclasses can simply be added or removed in the Factory. This only requires changing code in the Factory, or to the concrete instantiation, and not the client method.
    _Factories allow client code to operate on generalizations. This is known as coding to an interface, not an implementation: the client method does not need to name concrete knife classes and now deals with a Knife “generalization.” As long as the client code receives the object it expects, it can satisfy its responsibilities without worrying about the details of object creation.
    _Essentially, using factory objects means that you have cut out redundant code and made the software easier to modify, particularly if there are multiple clients that want to instantiate the same set of classes. Subclasses of the factory class can even become their own specialized factories!. Generally, in order to create a “specialized” product object, a Factory Object approach would subclass the factory class.
_   Concrete instantiation is the primary purpose of Factories. In general, a factory object is an instance of a factory class, which has a method to create product objects.
Factory Method Pattern:
_   The factory object is not actually a design pattern onto itself. The Factory method pattern does not use a factory object to create the objects; instead, the Factory method uses a separate “method” in the same class to create objects. The power of the Factory method comes in particular from how they create specialized product objects.
_   This design pattern’s intent is to define an interface for creating objects but lets the subclasses decide which class to instantiate. So, instead of working with a factory object, we specialize or subclass the class that uses the Factory Method. Each subclass must define its own Factory Method. This is known as letting the subclasses decide how objects are made.
    _There should be an abstract Creator class that contains methods that only operate on generalizations. The Factory Method is declared by the Creator abstractly, so each Concrete Creator class is obliged to provide a Factory Method.
    _There should also be a subclass of the abstract Creator class, a Concrete Creator that is responsible for concrete instantiation. The Concrete Creator inherits methods from the abstract Creator.
    _There should be a factoryMethod() in the concrete creator subclass. Every time a Concrete Creator subclass is added to the design, the factoryMethod() must be defined to make the right products. This is how the subclass “decides” to create objects.
    _Finally, the Product superclass generalizes the Concrete Products.
    _The methods of the Creator class only operate on the general Product, never the Concrete Products. The Concrete Products are made by the Concrete Creator. The type of product made is decided by which Concrete Creator is made.

2.1.5   Facade Pattern (Structural)
As systems or parts of systems become larger, they also become more complex. Client classes function better with a simpler interaction, however. The façade design pattern attempts to resolve this issue by providing a single, simplified interface for client classes to interact with a subsystem.
_   A façade is a wrapper class that encapsulates a subsystem in order to hide the subsystem’s complexity; it acts as a point of entry into a subsystem without adding more functionality in itself. The wrapper class allows a client class to interact with the subsystem through the façade.
_   A façade design pattern should therefore be used if there is a need to simplify the interaction with a subsystem for client classes and if there is a need for a class to instantiate other classes within your system and to provide these instances to another class. Often façade design patterns combine interface implementation by one or more classes, which then gets wrapped by the façade class. This can be explained through a number of steps:
    _1. Design the interface.
    _2. Implement the interface with one or more classes.
    _3. Create the façade class and wrap the classes that implement the interface.
    _4. Use the façade class to access the subsystem.
_   In summary, the façade design pattern:
    _Hides the complexity of a subsystem by encapsulating it behind a unifying wrapper called a façade class.
    _Removes the need for client classes to manage a subsystem on their own, which results in less coupling between the subsystem and the client classes.
    _Handles instantiation and redirection of tasks to the appropriate class within the subsystem.
    _Provides client classes with a simplified interface for the subsystem.
    _Acts simply as a point of entry to a subsystem and does not add more functional subsystems.

2.1.6   Adapter Pattern (Structural)
Facilitates communication between two existing systems by providing a compatible interface.
_   The adapter design pattern consists of several parts:
    _1. A client class. This class is the part of your system that wants to use a third-party library or external system.
    _2. An adaptee class. This class is the third-party library or external system that is to be used.
    _3. An adapter class. This class sits between the client and the adaptee. The adapter conforms to what the client is expecting to see, by implementing a target interface. The adapter also translates the client request into a message that the adaptee will understand, and returns the translated request to the adaptee. The adapter is a kind of wrapper class.
    _4. A target interface. This is used by the client to send a request to the adapter.
_   Implementation of an adapter design pattern can also be broken down into steps:
    _1. Design the target interface.
    _2. Implement the target interface with the adapter class.
    _3. Send the request from the client to the adapter using the target interface.
_   In summary, an adapter is meant to:
    _Wrap the adaptee and exposes a target interface to the client.
    _Indirectly change the adaptee’s interface into one that the client is expecting by implementing a target interface.
    _Indirectly translate the client’s request into one that the adaptee is expecting.
    _Reuse an existing adaptee with an incompatible interface.

2.1.7   Composite Pattern (Structural)
Allows to build a tree-like structure of objects and to treat individual types of those objects uniformly. This is achieved by:
    _Enforcing polymorphism across each class through implementing an interface (or inheriting from a superclass).
    _Using a technique called recursive composition that allows objects to be composed of other objects that are of a common type.
_   Is meant to achieve two goals:
    _To compose nested structures of objects: Individual types of objects, in particular, composite class objects, can aggregate component classes, which create a tree-like structure.
    _To deal with the classes for these objects uniformly: Each individual class is a subtype of an interface or superclass that will be able to conform to a set of shared behaviors.
_   In this design, a component interface serves as the supertype for a set of classes. Using polymorphism, all implementing classes conform to the same interface, which allows them to be dealt with uniformly. An abstract superclass can also be used in place of an interface, as both allow for polymorphism.
_   A composite class is present as well. This class is used to aggregate any class that implements the component interface. The composite class allows you to “traverse through” and “potentially manipulate” the component objects that the composite object contains.
_   A leaf class represents a non-composite type. It is not composed of other components. _The leaf class and the composite class implement the Component interface, unifying them with a single type. This allows us to deal with non-composite and composite objects uniformly – the Leaf class and the Composite class are now considered subtypes of Component. You may have other composite or leaf classes in practice, but there will only be one overall component interface or abstract superclass.
_   Another important concept to note is that a composite object can contain other composite objects since the composite class is a subtype of the component. This is known as recursive composition. This term is also a synonym for composite design patterns. Composites have the ability to “grow” a tree, while a leaf ends the tree where it is.
_  Expressing this pattern through a number of steps:
    _1. Design the interface that defines the overall type, that the composite and leaf classes will implement.
    _2. Implement the composite class.
    _3. Implement the leaf class
_   Composite design patterns apply the design principles of decomposition and generalization. They break a whole into parts but the whole and parts both conform to a common type. Complex structures can be built using composite objects and leaf objects that belong to a unified component type. This makes it easier to understand and manipulate this structure.

2.1.8   Proxy Pattern (Structural)
Allows a proxy class to represent a real “subject” class. A proxy is something that acts as a simplified, or lightweight version, of the original object. A proxy object can perform the same tasks as an original object but may delegate requests to the original object to achieve them.
_   In this design pattern, the proxy class wraps the real subject class. This means that a reference to an instance of the real subject class is hidden in the proxy class. The real object is usually a part of the software system that contains sensitive information, or that would be resource-intensive to instantiate. As the proxy class is a wrapper, client classes interact with it instead of the real subject class.
_   The three most common scenarios where proxy classes are used are:
    _To act as a virtual proxy. This is when a proxy class is used in place of a real subject class that is resource-intensive to instantiate. This is commonly used on images in web pages or graphic editors, as a high-definition image may be extremely large to load.
    _To act as a protection proxy. This is when a proxy class is used to control access to the real subject class. For example, a system that is used by both students and instructors might limit access based on roles.
    _To act as a remote proxy. This is when a proxy class is local, and the real subject class exists remotely. Google docs make use of this, where web browsers have all the objects it needs locally, which also exist on a Google server somewhere else.
_   Implementation of this pattern in Java can be broken down into steps:
    _1. Design the subject interface.
    _2. Implement the real subject class.
    _3. Implement the proxy class.
_   In summary, a proxy design pattern allows you to defer creating resource-intensive objects until needed, control access to specific objects, or when you need something to act as a local representation of a remote system. They made systems more secure, and less resource-intensive. The main features of a proxy design pattern are:
    _To use the proxy class to wrap the real subject class.
    _To have a polymorphic design so that the client class can expect the same interface for the proxy and real subject classes.
    _To use a lightweight proxy in place of a resource-intensive object until it is actually needed.
    _To implement some form of intelligent verification of requests from client code in order to determine if, how, and to whom the requests should be forwarded to.
    _To present a local representation of a system that is not in the same physical or virtual space.

2.1.9   Decorator Pattern (Structural)
Allows additional behaviors or responsibilities to be dynamically attached to an object, through the use of aggregation to combine behaviors at run time.
_   It is beneficial for software to have flexible combinations of overall behaviors. However, changes to classes cannot be made while a program is running, as the behavior of an object is defined by its class, and only occurs at compile time. A new class would need to be created in order to achieve a new combination of behaviors while a program is running. Lots of new combinations, however, would lead to lots of classes, which is undesirable.
_   Aggregation is a design principle used to represent a “has-a” or “weak containment” relationship between two objects. This can be used to build a stack of objects, also known as an “aggregation stack”, where each level of the stack contains an object that knows about its own behavior and augments the one underneath it.
_   In an aggregation stack, the aggregation relationship is always one-to-one in the decorator design pattern. This allows the stack to build up, so one object is on top of another.
_   This design pattern makes use of interfaces and inheritance so that the classes conform to a common type whose instances can be stacked in a compatible way. This builds a coherent combination of behavior overall.
_   It consists of a Component interface that defines the common type for all the classes. A client class expects the same interface across all the component classes. A
concrete component class implements the component interface and can be instantiated. An instance of this class can be used as a base object in the stack.
_   As indicated by the italics, Decorator is an abstract class. Similar to the concrete component class, it implements the component interface. However, the Decorator class aggregates other types of components, which will allow us to “stack” components on top of each other. It also serves as the abstract superclass of concrete decorator classes that will each provide an increment of behavior.
_   A stack of components can be built starting with an instance of the concrete component class and continuing with instances of subclasses of the decorator abstract class.
_   Decorator design patterns allow objects to dynamically add behaviors to others, and it reduces the number of classes needed to offer a combination of behaviors.
_   Implementation of this design pattern with Java can be broken down into steps:
    _1. Design the component interface.
    _2. Implement the interface with your base concrete component class.
    _3. Implement the interface with your abstract decorator class.
    _4. Inherit from the abstract decorator and implement the component interface with concrete decorator classes.
_   In summary, the main features of a decorate design pattern are:
    _We can add, in effect, any number of behaviors dynamically to an object at runtime by using aggregation as a substitute for pure inheritance.
    _Polymorphism is achieved by implementing a single interface.
    _Aggregation lets us create a stack of objects.
    _Each decorator object in the stack is aggregated in a one-to-one relationship with the object below it in the stack.
    _By combining aggregation and polymorphism, we can recursively invoke the same behavior down the stack and have the behavior execute upwards from the concrete component object.
_   The use of design patterns like the decorator pattern helps to create complex software, without the complex overhead.

2.2.1   Template Method Pattern (Behavioural)
Defines an algorithm’s steps generally, by deferring the implementation of some steps to subclasses. In other words, it is concerned with the assignment of responsibilities.
_   The template method is best used when you can generalize between two classes into a new superclass. Think of it as another technique to use when you notice you have two separate classes with very similar functionality and order of operations. You can choose to use a template method, so changes to these algorithms only need to be applied in one place instead of two. The template method would be within the superclass, and would therefore be inherited by the subclasses. Differences in algorithms would be done through calls to abstract methods whose implementations are provided by the subclass. After using generalization, objects can be more effectively reused. Inheritance allows functionality to be shared between classes and enables clearer and more self-explanatory code.

2.2.2	Chain of Responsibility Pattern (Behavioural)

















