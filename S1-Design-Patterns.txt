https://www.coursera.org/learn/design-patterns?specialization=software-design-architecture

Design Patterns
    Introduction to Design Patterns: Creational & Structural Patterns


2.1.1   What is a Design Pattern?
A design pattern is a practical proven solution to a recurring design problem. Instead of solving a particular software problem by basic objectory into programming principles every time, where you would have to decide what objects to use? How objects need to relate and so on? You can use previously outlined solutions that expert developers have often used.

Pattern Languages: is a collection of patterns that are related to a certain problem space. Based on context, you must decide which ones will suit your problem or design issue the best. However, sometimes you must consider trade-offs in design – some patterns may be more resource-intensive.

2.1.2   Categories of Patterns: The Gang of Four’s pattern catalog contains 23 patterns. These patterns can be sorted into three different categories: creational patterns, structural patterns, and behavioral patterns. Some patterns might have elements that allow them to span all of the categories – it is not always clear cut which categories a pattern falls under.
The different ways of creating objects will greatly influence how a problem is solved. Therefore, different languages therefore impact what patterns are possible to use.
_   Creational patterns: tackle how you handle creating or cloning new objects. Cloning an object occurs when you are creating an object that is similar to an existing one, and instead of instantiating a new object, you clone existing objects instead of instantiating them.
The different ways of creating objects will greatly influence how a problem is solved. Therefore, different languages therefore impact what patterns are possible to use.
_   Structural patterns: describe how objects are connected to each other. These patterns relate to the design principles of decomposition and generalization, as discussed in the first course in this specialization. Also describe how subclasses and classes interact through inheritance. Structural patterns use these relationships and describe how they should work to achieve a particular design goal. Each structural pattern determines the various suitable relationships among the objects.
_   Behavioral patterns: focus on how objects distribute work and describe how each object does a single cohesive function. Behavioral patterns also focus on how independent objects work towards a common goal.

2.1.3   Singleton Pattern (Creational)
Describes a way to create an object. It is a powerful technique, but it is also one of the simplest examples of a design pattern.
_   A singleton design pattern only has one object of a class. This might be desirable in order to circumvent conflicts or inconsistencies, by keeping clear which object the program should draw from. For example, the preferences of an app, the print queue of your printer, or the software driver for a device are all objects where it is preferable to only have one. If there are multiple instances, it can be confusing for the program output.
_   Another goal of the singleton design pattern is that the single object is globally accessible within the program.
_   In order to implement a singleton design pattern, the best practice is to build the “one and only one” goal into the class itself so that creating another instance of a Singleton class is not even possible. This “codifies” the design intent within the software. This is necessary if working on a large project or on projects with multiple developers, but it is helpful even on smaller or individual projects.
_   A Singleton class Lazy creation version means that the object is not created until it is truly needed. This is helpful, especially if the object is large. As the object is not created until the “getInstance” method is called, the program is more efficient.
_   There are trade-offs to the Singleton design principle. If there are multiple computing threads running, there could be issues caused by the threads trying to access the shared single object.
_   In real use, there may be variations of how Singleton is realized because design patterns are defined by purpose and not exact code. The intent of a Singleton pattern is to provide global access to a class that is restricted to one instance. In general, this is achieved by having a private constructor with a public method that instantiates the class “if” it is not already instantiated.

2.1.4   Factory Method Pattern (Creational)
In order to understand the Factory method pattern, we must first understand factory objects.
Factory object:
_   Operates like a factory in the real world, and creates objects. Factory objects make software easier to maintain, change, test, and reuse because it deals with the problem of creating objects without having to specify the class. The methods that use these factories can then focus on other behaviors.
_   A factory object is an object whose role is to create “product” objects of particular types.
_   The act of instantiating a class to create an object of a specific type is known as concrete instantiation. In Java, concrete instantiation is indicated with the operator “new”.
_   Benefits of Factory Objects:
    _It is much simpler to add new types of an object to the object factory without modifying the client code. Instead of hunting down multiple snippets of similar instantiation code, subclasses can simply be added or removed in the Factory. This only requires changing code in the Factory, or to the concrete instantiation, and not the client method.
    _Factories allow client code to operate on generalizations. This is known as coding to an interface, not an implementation: the client method does not need to name concrete knife classes and now deals with a Knife “generalization.” As long as the client code receives the object it expects, it can satisfy its responsibilities without worrying about the details of object creation.
    _Essentially, using factory objects means that you have cut out redundant code and made the software easier to modify, particularly if there are multiple clients that want to instantiate the same set of classes. Subclasses of the factory class can even become their own specialized factories!. Generally, in order to create a “specialized” product object, a Factory Object approach would subclass the factory class.
_   Concrete instantiation is the primary purpose of Factories. In general, a factory object is an instance of a factory class, which has a method to create product objects.
Factory Method Pattern:
_   The factory object is not actually a design pattern onto itself. The Factory method pattern does not use a factory object to create the objects; instead, the Factory method uses a separate “method” in the same class to create objects. The power of the Factory method comes in particular from how they create specialized product objects.
_   This design pattern’s intent is to define an interface for creating objects but lets the subclasses decide which class to instantiate. So, instead of working with a factory object, we specialize or subclass the class that uses the Factory Method. Each subclass must define its own Factory Method. This is known as letting the subclasses decide how objects are made.
    _There should be an abstract Creator class that contains methods that only operate on generalizations. The Factory Method is declared by the Creator abstractly, so each Concrete Creator class is obliged to provide a Factory Method.
    _There should also be a subclass of the abstract Creator class, a Concrete Creator that is responsible for concrete instantiation. The Concrete Creator inherits methods from the abstract Creator.
    _There should be a factoryMethod() in the concrete creator subclass. Every time a Concrete Creator subclass is added to the design, the factoryMethod() must be defined to make the right products. This is how the subclass “decides” to create objects.
    _Finally, the Product superclass generalizes the Concrete Products.
    _The methods of the Creator class only operate on the general Product, never the Concrete Products. The Concrete Products are made by the Concrete Creator. The type of product made is decided by which Concrete Creator is made.

2.1.5   Facade Pattern (Structural)
As systems or parts of systems become larger, they also become more complex. Client classes function better with a simpler interaction, however. The façade design pattern attempts to resolve this issue by providing a single, simplified interface for client classes to interact with a subsystem.
_   A façade is a wrapper class that encapsulates a subsystem in order to hide the subsystem’s complexity; it acts as a point of entry into a subsystem without adding more functionality in itself. The wrapper class allows a client class to interact with the subsystem through the façade.
_   A façade design pattern should therefore be used if there is a need to simplify the interaction with a subsystem for client classes and if there is a need for a class to instantiate other classes within your system and to provide these instances to another class. Often façade design patterns combine interface implementation by one or more classes, which then gets wrapped by the façade class. This can be explained through a number of steps:
    _1. Design the interface.
    _2. Implement the interface with one or more classes.
    _3. Create the façade class and wrap the classes that implement the interface.
    _4. Use the façade class to access the subsystem.
_   In summary, the façade design pattern:
    _Hides the complexity of a subsystem by encapsulating it behind a unifying wrapper called a façade class.
    _Removes the need for client classes to manage a subsystem on their own, which results in less coupling between the subsystem and the client classes.
    _Handles instantiation and redirection of tasks to the appropriate class within the subsystem.
    _Provides client classes with a simplified interface for the subsystem.
    _Acts simply as a point of entry to a subsystem and does not add more functional subsystems.

2.1.6   Adapter Pattern (Structural)
Facilitates communication between two existing systems by providing a compatible interface.
_   The adapter design pattern consists of several parts:
    _1. A client class. This class is the part of your system that wants to use a third-party library or external system.
    _2. An adaptee class. This class is the third-party library or external system that is to be used.
    _3. An adapter class. This class sits between the client and the adaptee. The adapter conforms to what the client is expecting to see, by implementing a target interface. The adapter also translates the client request into a message that the adaptee will understand, and returns the translated request to the adaptee. The adapter is a kind of wrapper class.
    _4. A target interface. This is used by the client to send a request to the adapter.
_   Implementation of an adapter design pattern can also be broken down into steps:
    _1. Design the target interface.
    _2. Implement the target interface with the adapter class.
    _3. Send the request from the client to the adapter using the target interface.
_   In summary, an adapter is meant to:
    _Wrap the adaptee and exposes a target interface to the client.
    _Indirectly change the adaptee’s interface into one that the client is expecting by implementing a target interface.
    _Indirectly translate the client’s request into one that the adaptee is expecting.
    _Reuse an existing adaptee with an incompatible interface.

2.1.7   Composite Pattern (Structural)
Allows to build a tree-like structure of objects and to treat individual types of those objects uniformly. This is achieved by:
    _Enforcing polymorphism across each class through implementing an interface (or inheriting from a superclass).
    _Using a technique called recursive composition that allows objects to be composed of other objects that are of a common type.
_   Is meant to achieve two goals:
    _To compose nested structures of objects: Individual types of objects, in particular, composite class objects, can aggregate component classes, which create a tree-like structure.
    _To deal with the classes for these objects uniformly: Each individual class is a subtype of an interface or superclass that will be able to conform to a set of shared behaviors.
_   In this design, a component interface serves as the supertype for a set of classes. Using polymorphism, all implementing classes conform to the same interface, which allows them to be dealt with uniformly. An abstract superclass can also be used in place of an interface, as both allow for polymorphism.
_   A composite class is present as well. This class is used to aggregate any class that implements the component interface. The composite class allows you to “traverse through” and “potentially manipulate” the component objects that the composite object contains.
_   A leaf class represents a non-composite type. It is not composed of other components. _The leaf class and the composite class implement the Component interface, unifying them with a single type. This allows us to deal with non-composite and composite objects uniformly – the Leaf class and the Composite class are now considered subtypes of Component. You may have other composite or leaf classes in practice, but there will only be one overall component interface or abstract superclass.
_   Another important concept to note is that a composite object can contain other composite objects since the composite class is a subtype of the component. This is known as recursive composition. This term is also a synonym for composite design patterns. Composites have the ability to “grow” a tree, while a leaf ends the tree where it is.
_  Expressing this pattern through a number of steps:
    _1. Design the interface that defines the overall type, that the composite and leaf classes will implement.
    _2. Implement the composite class.
    _3. Implement the leaf class
_   Composite design patterns apply the design principles of decomposition and generalization. They break a whole into parts but the whole and parts both conform to a common type. Complex structures can be built using composite objects and leaf objects that belong to a unified component type. This makes it easier to understand and manipulate this structure.

2.1.8   Proxy Pattern (Structural)
Allows a proxy class to represent a real “subject” class. A proxy is something that acts as a simplified, or lightweight version, of the original object. A proxy object can perform the same tasks as an original object but may delegate requests to the original object to achieve them.
_   In this design pattern, the proxy class wraps the real subject class. This means that a reference to an instance of the real subject class is hidden in the proxy class. The real object is usually a part of the software system that contains sensitive information, or that would be resource-intensive to instantiate. As the proxy class is a wrapper, client classes interact with it instead of the real subject class.
_   The three most common scenarios where proxy classes are used are:
    _To act as a virtual proxy. This is when a proxy class is used in place of a real subject class that is resource-intensive to instantiate. This is commonly used on images in web pages or graphic editors, as a high-definition image may be extremely large to load.
    _To act as a protection proxy. This is when a proxy class is used to control access to the real subject class. For example, a system that is used by both students and instructors might limit access based on roles.
    _To act as a remote proxy. This is when a proxy class is local, and the real subject class exists remotely. Google docs make use of this, where web browsers have all the objects it needs locally, which also exist on a Google server somewhere else.
_   Implementation of this pattern in Java can be broken down into steps:
    _1. Design the subject interface.
    _2. Implement the real subject class.
    _3. Implement the proxy class.
_   In summary, a proxy design pattern allows you to defer creating resource-intensive objects until needed, control access to specific objects, or when you need something to act as a local representation of a remote system. They made systems more secure, and less resource-intensive. The main features of a proxy design pattern are:
    _To use the proxy class to wrap the real subject class.
    _To have a polymorphic design so that the client class can expect the same interface for the proxy and real subject classes.
    _To use a lightweight proxy in place of a resource-intensive object until it is actually needed.
    _To implement some form of intelligent verification of requests from client code in order to determine if, how, and to whom the requests should be forwarded to.
    _To present a local representation of a system that is not in the same physical or virtual space.

2.1.9   Decorator Pattern (Structural)
Allows additional behaviors or responsibilities to be dynamically attached to an object, through the use of aggregation to combine behaviors at run time.
_   It is beneficial for software to have flexible combinations of overall behaviors. However, changes to classes cannot be made while a program is running, as the behavior of an object is defined by its class, and only occurs at compile time. A new class would need to be created in order to achieve a new combination of behaviors while a program is running. Lots of new combinations, however, would lead to lots of classes, which is undesirable.
_   Aggregation is a design principle used to represent a “has-a” or “weak containment” relationship between two objects. This can be used to build a stack of objects, also known as an “aggregation stack”, where each level of the stack contains an object that knows about its own behavior and augments the one underneath it.
_   In an aggregation stack, the aggregation relationship is always one-to-one in the decorator design pattern. This allows the stack to build up, so one object is on top of another.
_   This design pattern makes use of interfaces and inheritance so that the classes conform to a common type whose instances can be stacked in a compatible way. This builds a coherent combination of behavior overall.
_   It consists of a Component interface that defines the common type for all the classes. A client class expects the same interface across all the component classes. A
concrete component class implements the component interface and can be instantiated. An instance of this class can be used as a base object in the stack.
_   As indicated by the italics, Decorator is an abstract class. Similar to the concrete component class, it implements the component interface. However, the Decorator class aggregates other types of components, which will allow us to “stack” components on top of each other. It also serves as the abstract superclass of concrete decorator classes that will each provide an increment of behavior.
_   A stack of components can be built starting with an instance of the concrete component class and continuing with instances of subclasses of the decorator abstract class.
_   Decorator design patterns allow objects to dynamically add behaviors to others, and it reduces the number of classes needed to offer a combination of behaviors.
_   Implementation of this design pattern with Java can be broken down into steps:
    _1. Design the component interface.
    _2. Implement the interface with your base concrete component class.
    _3. Implement the interface with your abstract decorator class.
    _4. Inherit from the abstract decorator and implement the component interface with concrete decorator classes.
_   In summary, the main features of a decorate design pattern are:
    _We can add, in effect, any number of behaviors dynamically to an object at runtime by using aggregation as a substitute for pure inheritance.
    _Polymorphism is achieved by implementing a single interface.
    _Aggregation lets us create a stack of objects.
    _Each decorator object in the stack is aggregated in a one-to-one relationship with the object below it in the stack.
    _By combining aggregation and polymorphism, we can recursively invoke the same behavior down the stack and have the behavior execute upwards from the concrete component object.
_   The use of design patterns like the decorator pattern helps to create complex software, without the complex overhead.

2.2.1   Template Method Pattern (Behavioural)
Defines an algorithm’s steps generally, by deferring the implementation of some steps to subclasses. In other words, it is concerned with the assignment of responsibilities.
_   The template method is best used when you can generalize between two classes into a new superclass. Think of it as another technique to use when you notice you have two separate classes with very similar functionality and order of operations. You can choose to use a template method, so changes to these algorithms only need to be applied in one place instead of two. The template method would be within the superclass, and would therefore be inherited by the subclasses. Differences in algorithms would be done through calls to abstract methods whose implementations are provided by the subclass. After using generalization, objects can be more effectively reused. Inheritance allows functionality to be shared between classes and enables clearer and more self-explanatory code.

2.2.2	Chain of Responsibility Pattern (Behavioural)
Is a chain of objects that are responsible for handling requests. In software design, these objects are handler objects that are linked together.
_   When a client object sends a request, the first handler in the chain will try to process it. If the handler can process the request, then the request ends with this handler. However, if the handler cannot handle the request, then the request is sent to the next handler in the chain. This process will continue until a handler can process the request. If the entire chain is unable to handle the request, then the request is not satisfied.
_   The chain of responsibility is an important pattern in software. This pattern avoids coupling the sender to the receiver by giving more than one object a chance to handle the request. Whoever sends the request does not need to to worry about who will handle the request, so the sender and the receiver are decoupled from each other. The chain of responsibility also helps deal with situations in which streams of different requests need to be handled.
_   This pattern is similar to exception handling in Java. In exception handling, a series of try/catch blocks are written in your software to ensure that exceptions are dealt with properly. When an exception occurs, one of the catch blocks is expected to handle it.
_   The chain of responsibility can be used for many different purposes. For example, it is commonly used for filtering objects, such as putting certain emails into a spam folder.
_   The chain of responsibility pattern does not come without potential issues. For example, what if there’s a mistake in the second filter and its rule doesn’t match but forgets to pass the request on to the next filter. In this case, the handling ends prematurely. To circumvent this problem, there needs to be an algorithm that ensures each filter class handles requests in a similar fashion. Each filter needs to go through the following steps:
    _1. Check if the rule matches.
    _2. If it matches, do something specific.
    _3. If it doesn’t match, call the next filter in the list.
    _It may be helpful to use the template pattern to ensure that each class will handle a request in a similar way, following the above steps.

2.2.3   State Pattern (Behavioural)
This pattern should be primarily used when you need to change the behavior of an object based upon changes to its internal state or the state it is in at run-time. This pattern can also be used to simplify methods with long conditionals that depend on the object’s state.
_   Objects in your code are aware of their current state. They can choose an appropriate behavior based on their current state. When their current state changes, this behavior can be altered - this is the state design pattern.
_   Using the State design pattern, long conditionals are not necessary for the methods and creates much cleaner code.

2.2.4   Command Pattern (Behavioural)
Encapsulates a request as an object of its own. In general, when an object makes a request for a second object to do an action, the first object would call a method of the second object and the second object would complete the task. There is direct communication between the sender and receiver object. The command pattern creates a command object between the sender and receiver. This way, the sender does not have to know about the receiver and the methods to call.
_   An invoker is therefore an object that invokes the command objects to complete whatever task it is supposed to do. A command manager can also be used that basically keeps track of the commands, manipulates them, and invokes them.
_   There are many different purposes for using the command pattern:
    _Store and schedule different requests. If requests are turned into command objects in your software, then they can be stored into lists and manipulated before they are completed.
    _Allow commands to be undone or redone. For example, edits can be undone or redone in a document.
_   The command pattern lets you do things to requests that you wouldn’t be able to do if they were simple method calls from one object to the other. Commands can also be stored in a log list, so if the software crashes unexpectedly, users can redo all the recent commands.
_   Benefits of the Command Pattern:
    _Allows commands to be manipulated as objects. Functionalities can be added to the command objects, such as putting them into queues and adding undo/redo functions.
    _Decouple the objects of your software program, as classes do not need to know about other objects in the software system – the command object deals with the work by invoking receiver objects.
    _Allows logic to be pulled from user interfaces. User interface classes should only be dealing with issues like getting information to and from the user, and application logic should not be in user interface classes.
_   The command pattern creates a layer where command objects go, so that every time a button is clicked on the interface, a command object is created. This is where application logic will sit instead. The command objects are independent of the user interface so that adding changes like new buttons to the interface is easier and faster.
_   Each and every service in a system can be an object of its own, allowing for more flexible functionality. This pattern can be a great asset to making versatile and easy-to-maintain software programs.

2.2.4a   Mediator Pattern (Behavioural)
Add an object that will talk to all of these other objects and coordinate their activities. Now, instead of objects being engaged in various pairwise interactions, they all interact through the mediator.
_   The communication between an object and the mediator is two-way: the object informs the mediator when something happens. The mediator can perform logic on these events. Finally, the mediator can request information or behaviour from an object.
_   The objects associated with your mediator are called colleagues. You define an interface for the interactions between the mediator and colleagues, then instantiate a concrete mediator and concrete colleagues as necessary.
_   The communication could be implemented as an Observer pattern. Each Colleague is a subclass of the Observable class, and the Mediator is an Observer to each of them. In this case, the colleague should pass itself as a parameter to the mediator, so that the mediator knows to check that colleague instead of checking all of them. The communication could also occur through an event infrastructure.
_   A common usage for the mediator pattern, identified by the Gang of Four, is for dialog boxes with many components. As the user makes selections, such as checking a box or choosing a certain bullet out of a list, other parts of the dialog may have to be grayed out or changed in some other way. Instead of components talking to each other directly, a mediator can easily manage the different interactions like this.
_   The Mediator allows for loose coupling between colleagues. Since each of these colleagues only communicates with the mediator, they can be reused more easily. Centralizing the logic of interaction between all of these related objects in one central object makes for code that is easier to read, maintain, and extend.
_   On the other hand, the mediator can quickly become very large. Large classes are generally discouraged because they make code more difficult to debug. The benefits of centralization should be balanced against the downsides of a large, difficult-to-read mediator class.

2.2.5 – Observer Pattern (Behavioural)
A subject keeps a list of observers. Observers rely on the subject to inform them of changes to the state of the subject.
_   In an observer design pattern, there is generally a Subject superclass, which would have an attribute to keep track of all the observers. There is also an Observer interface with a method so that an observer can be notified of state changes to the subject. The Subject superclass may also have subclasses that implement the Observer interface. These elements create the relationship between the subject and observer.
_   Observer design patterns save time when implementing a system. If many objects rely on the state of one, the observer design pattern has even more value. Instead of managing all observer objects individually, the subject manages them and ensures observers are updating themselves as needed.
_   This behavior pattern is typically used to make it easy to distribute and handle notifications of changes across systems in a manageable and controlled way.

2.3.1 – MVC Pattern
Model, View, Controller (MVC) pattern is a pattern that should be considered for use with user interfaces. MVC patterns divide the responsibilities of a system that offers a user interface into three parts: model, view, and controller.
_   The Model is going to contain the underlying data, state, and logic that users want to see and manipulate through an interface. It is the “back end”, or the underlying software.
_   The View gives users the way to see the model in the way they expect and allows them to interact with it or at least parts of it. It is the “front end” or the presentation layer of the software. A model could have several views that present different parts of the model, or present the model in different ways. When a value changes in the model, the view needs to be notified, so it can update itself accordingly. The observer design pattern allows this to happen.
_   The controller is responsible for interpreting requests and interacts with elements in the view, and changing the model. The view is therefore only responsible for the visual appearance of the system. The model focuses only on managing the information for the system.
_   A key aspect of the MVC pattern is that the model is self-contained. It has all of the state, methods, and other data needed to exist on its own.
_   The MVC pattern uses the separation of concerns design principle to divide up the main responsibilities in an interactive system. The controller ensures that the views and the model are loosely coupled. The model corresponds to entity objects, which are derived from analyzing the problem space for the system. The view corresponds to a boundary object, which is at the edge of your system that deals with users. The controller corresponds to a control object, which receives events and coordinates actions.
_   Controllers make the code cleaner and easier to modify. Note that in most software systems, there are generally multiple models, view, and controller classes. Controllers make the code better in the following ways:
    _The view can focus on its main purpose: presenting the user interface, as the controller takes the responsibility of interpreting the input from the user and working with the model based on that input.
    _The view and the model are not “tightly coupled” when a controller is between them. Features can be added to the model and tested long before they are added to the view.
_   MVC patterns may be used in many ways. The defining feature of the MVC pattern is the separation of concerns between the back-end, the front-end, and the coordination between the two.

2.3.1a – Liskov Substitution Principle
If a class, S, is a subtype of a class, B, then S can be used to replace all instances of B without changing the behaviors of a program.
_   The logic behind this is straightforward. If S is a subtype of B, then it can be expected that S will have the same behaviours as B. Therefore, S can be used in place of B and it would not affect the software. This means that inheritance can be tested by applying substitution. If inheritance is not used correctly, it can lead to a violation of the “Liskov Substitution Principle”.
_   Inheritance Guidelines: There are a number of constraints that the Liskov Substitution Principle places on subclasses in order to enforce proper use of inheritance:
    _1. The condition used to determine if a base class should or should not invoke a method cannot be "strengthened" by a subclass. That is, a subclass cannot add more conditions to determine if a method should be called.
    _2. The condition of the program after the execution of a method cannot be "weakened" by a subclass. This means that the subclass should cause the state of the program to be in the same state as the base class after a method call. Subclasses are allowed to "strengthen" the postcondition of a program. For example, if the base class sets an alarm for a specific date, the subclass must do the same, but the result can be more precise by setting the specific hour as well.
    _3. Invariant conditions that exist in the base class, must also remain invariant in the subclass. Since invariant conditions are expected to be immutable, the subclass should not change them as it may cause a side effect in the behaviours of the base class or the program.
    _4. Immutable characteristics of a base class must not be changed by the subclass. Since classes can modify their own characteristics, a subclass can modify all the characteristics that it inherits from the base. However, the base class may encapsulate attributes that should be fixed values. These values are identifiable by observing whether or not they are changed in the program, or by a method in the base class. If it is not changed, then these attributes are considered immutable. Subclasses can get around this problem by declaring and modifying their own attributes. The attributes of a subclass are not visible to the base class and therefore, do not affect the behaviour of the base class.
_   These rules are not programmatically enforced by any object-oriented language. In fact, overriding a base class's behaviors can have advantages. Subclasses can improve the performance of behaviours of its base class, without changing the expected results of said behavior.
_   The Liskov Substitution Principle helps us determine if inheritance has been used correctly. If the expected behaviour between the subclass and the base class is different, then the principle has been violated.

2.3.2 – Open/Closed Principle
States that classes should be open for extension but closed to change.
_   A class is considered “closed” to editing once it has:
    _Been tested to be functioning properly. The class should behave as expected.
    _All the attributes and behaviors are encapsulated.
    _Been proven to be stable within your system. The class or any instance of the class should not stop your system from running or do it harm.
_   Although the principle is called “closed”, it does not mean that changes cannot be made to a class during development. A “closed” class occurs when a point has been reached in development when most of the design decisions have been finalized and once you have implemented most of your system.
_   During the lifecycle of your software, certain classes should be closed to further changes to avoid introducing undesirable side effects. A “closed” class should still be fixed if any bugs or unexpected behaviors occur. If a system needs to be extended or have more features added, then the “open” side of the principle comes into play.
_   An “open” class is one that can still be built upon. There are two different ways to extend a system with the open principle:
    _The first way is through the inheritance of a superclass. Inheritance can be used to simply extend a class that is considered closed when you want to add more attributes and behaviors. The subclasses will have the original functions of the superclass, but extra features can be added in the subclasses. This helps preserve the integrity of the superclass, so if the extra features of the subclasses are not needed, the original class can still be used. Note that subclasses can also be extended, so this allows the open/closed principle to continually extend your system as much as desired.
    _The second way a class can be open is when the class is abstract and enforces the open/closed principle through polymorphism. An abstract class can declare abstract methods with just the method signatures. Each concrete subclass must provide its own implementation of these methods. The methods in the  abstract superclass are preserved, and the system can be extended by providing different implementations for each method. This is useful for behaviors like sorting or searching. An interface can also enable polymorphism, but remember that it will not be able to define a common set of attributes.
_   If you want to limit a class so that it is no longer extendable, it can be declared as “final” to prevent further inheritance. This keyword can also be used for methods.
_   The open/closed principle is used to keep stable parts of a system separate from varying parts. It allows the addition of new features to a system, but without the expense of disrupting working parts.
_   The open/closed principle:
    _Helps keep a system stable by “closing” classes to change.
    _Allows a system to open for extension through inheritance or interfaces.

2.3.3 – Dependency Inversion Principle
The principle states that high-level modules should depend on high-level generalizations, and not on low-level details. This keeps client classes independent of low-level functionality.
_   This suggests that client classes should depend on an interface or abstract class, rather than a concrete resource. Further, concrete resources should have their behaviors generalized into an interface or abstract class. Interfaces and abstract classes are high-level resources. They define a general set of behaviors. Concrete classes are low-level resources. They provide the implementation for behaviors.
_   In a low-level dependency, the client classes name and make direct references to a concrete class. Subsystems are directly dependent on each other, so the client class will directly reference some concrete class in the enterprise subsystem, which will directly reference some concrete class in your backend.
    _Large changes are impractical and could entail unexpected side effects if old references are missed. The dependency inversion principle addresses this issue by generalizing low-level functionality into interfaces or abstract classes. This way, when alternative implementations are offered, they can be used with ease.
_   In high-level dependency, the client class is dependent on a high-level generalization rather than a low-level concrete class, allowing changes to be more easily made to resources. The generalization gives a degree of indirection by allowing behaviors to be invoked in a concrete class through an interface.
    _High-level dependency prevents the client class from being directly coupled with a specific concrete class. A client class is dependant on expected behaviors, not on a specific implementation of behaviors.
_   When the dependency inversion principle and high-level dependency are used, the overall architecture of a system will look similar to design patterns explored earlier in this course. Behaviors are generalized across each subsystem into an interface. The concrete classes of each subsystem will then implement the interface. Client classes will make references to the interface instead of directly to the concrete classes.
_   Object-oriented designs should use method calls through a level of indirection. The dependency inversion principle facilitates the use of indirections by writing dependencies to generalizations, rather than to a concrete class. It helps insulate parts of a system from specific implementations of functionality. It is best practice to program to generalizations, like interfaces and abstract classes, rather than directly to a concrete class.
_   The dependency inversion principle is a means to:
    _Change the referencing of concrete classes from being direct to indirect.
    _Generalize the behaviors of your concrete classes into abstract classes and interfaces.
    _Have client classes interact with your system through a generalization rather than directly with concrete resources.
    _Put emphasis on high-level dependency over low-level concrete dependency.
_   Using the dependency inversion principle may seem like extra work, but the effort is worthwhile, particularly if you are working on a large system. If a system is too heavily coupled, changes will be difficult to make. This principle helps ensure a robust software solution.

/
Less coupling in your system means that your system can be more flexible and is capable of handling changes to its existing code base such as the integration of new features.The design patterns that we have explored make heavy use of generalization, abstraction and polymorphism as means of indirection. While inheritance is a great way to achieve a high amount of code reuse, it comes with the cost of tightly coupling the super class with its subclasses.
/

2.3.4 – Composing Objects Principle
Inheritance can be a great way to achieve a high level of code reuse; it entails a cost of tightly coupling superclasses with their subclasses. Subclasses inherit all attributes and methods of a superclass, as long as access modifiers are not private. This means that if you have multiple levels of inheritance, a subclass at the bottom of the inheritance tree can potentially provide access to  attributes and behaviors of all the superclasses.
_   Coupling objects principle is a means of circumventing this problem, by providing a means for a high amount of code reuse without using inheritance. The principle states that classes should achieve code reuse through aggregation rather than inheritance. Aggregation and delegation offer less coupling than inheritance, since the composed classes do not share attributes or implementations of behaviors, and are more independent of each other. This means they have an 
_   Design patterns like the composite design pattern and decorator design pattern use this design principle. These two patterns compose concrete classes to build more complex objects at run time. The overall behavior comes from the composed sum of the individual objects. An object can reuse and aggregate another object to delegate certain requests to it. The system should be designed so that concrete classes can delegate tasks to other concrete classes.
_   The way classes will compose themselves is determined during design. Objects can be composed recursively and uniformly, or they can be composed of other objects that have a consistent type.
_   Composing objects provides your system with more flexibility:
    _When  objects are composed,  it is not required to find commonalities between two classes and couple them together with inheritance. Instead, classes can be designed to work together without sharing anything. This provides flexibility, especially if the system requirements change. Inheritance may require restructuring the inheritance tree.
    _Composing objects also allows the dynamic change of behaviors of objects at run time. A new overall combination of  behavior can be built by composing objects. Inheritance, on the other hand, requires behaviors of classes to be defined during compile-time, so they cannot change while the program is running.
_   Disadvantages to keep in mind for composition:
    _In composition, implementations for all behavior must be provided, without the benefit of inheritance to share code.
    _There could be very similar implementations across classes, which could take time and resources. With inheritance, common implementation is simply accessed within the superclass, so each subclass does not have to have its own implementation of shared behavior.
_   In summary, the composing objects principle will:
    _Provide a means of code reuse without the tight coupling of inheritance.
    _Allow objects to dynamically add behaviors at run time.
    _Provide your system with more flexibility, so that less time needs to be spent on system updates.
_   Although composing provides better flexibility and less coupling, while maintaining reusability, there is a place for inheritance. In order to determine which design principle is appropriate to use, you must assess the needs of your system, and choose what best fits the situation and problem at hand.

S3 - 2.3.5 – Interface Segregation Principle
The principle states that a class shouldn't be forced to depend on methods it does not use. This means that any classes that implement an interface should not have “dummy” implementations of any methods defined in the interfaces. Instead, large interfaces should be split into smaller generalizations.
_   In general, your design should strive to program to interfaces instead of concrete classes. However, if there is only a single interface that holds all the methods for all the clients, then all clients will have to unnecessarily implement all other clients’ methods just to make their interface compile.
_   Interfaces are an integral part of object-oriented systems. They reduce coupling by generalizing concrete classes. However, they must be used properly. Large interfaces in and of themselves are not necessarily a poor design choice, but you need to take into account the context of your system to decide if the interface segregation principle should be applied and if the interfaces should be split into smaller generalizations.
_   Note that it will not always be clear how to properly segregate your interfaces, or to predict future changes in requirements that will need interfaces to be split up. Well-defined interfaces are important – interfaces are descriptions of what parts of your system can do. The better the description the easier it will be to create, update, and maintain software.
_   In summary, the interface segregation principle states that:
    _A class should not be forced to depend on methods it does not use.
    _Interfaces should be split up in such a way that they can properly describe the separate functionalities of your system.

2.3.6 – Principle of Least Knowledge
This principle arises from one means of managing complexity, which suggests that a class should be designed so that it does not need to know about and depend upon almost every other class in the system. If classes have a narrow view of what other classes it knows, then coupling is decreased, and a system is easier to maintain.
_   This principle is also realized in a rule known as the Law of Demeter. The Law of Demeter is composed of several different rules that provide guidelines as to what kind of method calls a particular method can make – in other words, they help determine how classes should interact. This design principle focuses on how method calls should be made, rather than on specific ways of structuring the design of a system.
_   The four rules of the Law of Demeter as summarized below: A method, M, of an object should only call other methods if they are:
    _1. Encapsulated within the same object. In other words, a method encapsulated within a class is allowed to call any other method also encapsulated within the same class.
    _2. Encapsulated within an object that is in the parameters of M. As a method parameter is considered local to the method, methods in the class for the parameter are allowed to be called.
    _3. Encapsulated within an object that is instantiated inside the M. This means that if a method makes a new object, then the method is allowed to use that new object’s methods. The object is considered local to the creating method, the same way an object is considered local when it is a parameter.
    _4. Encapsulated within an object that is referenced in an instance variable of the class for M. This means that a method of a class can call methods of the classes of its instance variables. If a class has direct reference to the Friend class, any method inside of O is allowed to call any method of Friend class.
_   The Law of Demeter may seem complicated and abstract, but at its core, boils down to the idea that a method should not be allowed to access another method by “reaching through” an object. This means that a method should not invoke methods of any object that is not real.
_   The four rules explained above help outline what is considered a local object. These objects should be passed in through a parameter, or they should be instantiated within a method, or they should be in instance variables. This allows methods to directly access the behaviors of local objects.
_   These conditions commonly occur when you have a chain method calls to objects you should not know about, or when you use methods from an “unknown” type of object that is returned back to you from your local method call. A good metaphor for this is driving a car. When you drive a car, you do not issue individual commands to every component of the car. Instead, you simply tell the car to drive, and the car will know to deal with its components.
_   Another way you can “reach through” an object is when the method receives an object of an unknown type as a return value, and you make method calls to the returned object. Returned objects must be of the same type as:
    _Those declared in the method parameter
    _Those declared and instantiated locally in the method
    _Those declared in instance variable of the class that encapsulates the method
_   The Law of Demeter defines how classes should interact with each other. They should not have full access to the entire system because this causes a high degree of coupling. A class should only interact with those that are considered immediate “friends”. This prevents unwanted effects from cascading through the entire system.
_   Although the Law of Demeter can help reduce coupling, you should recognize that it also requires more time when designing and implementing a system. It may not always be feasible to follow the Law of Demeter due to limitations of time and resources. Other times, some degree of coupling may be unavoidable, at which point, you’ll need to decide how much coupling is tolerable.




































